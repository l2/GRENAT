<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of toolGeneMonomial</title>
  <meta name="keywords" content="toolGeneMonomial">
  <meta name="description" content="% Build MATLAB's functions of monomial basis (depending on the order and the number of variables)">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- ../../menu.html GRENAT --><!-- # src --><!-- menu.html kernANDfun -->
<h1>toolGeneMonomial
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>% Build MATLAB's functions of monomial basis (depending on the order and the number of variables)</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function toolGeneMonomial(polyOrder,nbVar) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment">% Build MATLAB's functions of monomial basis (depending on the order and the number of variables)
 L.LAURENT -- 25/02/2012 -- luc.laurent@lecnam.net</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../GRENAT/src/libs/Monomial/mono_upto_next_grlex.html" class="code" title="function x = mono_upto_next_grlex ( m, n, x )">mono_upto_next_grlex</a>	*****************************************************************************80</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="../../../GRENAT/src/surrogate/@xLS/buildFunPoly.html" class="code" title="function buildFunPoly(obj,polyOrder,nP)">buildFunPoly</a>	% Method of xLS class</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">%% Build MATLAB's functions of monomial basis (depending on the order and the number of variables)</span>
0002 <span class="comment">% L.LAURENT -- 25/02/2012 -- luc.laurent@lecnam.net</span>
0003 
0004 <span class="comment">%     GRENAT - GRadient ENhanced Approximation Toolbox</span>
0005 <span class="comment">%     A toolbox for generating and exploiting gradient-enhanced surrogate models</span>
0006 <span class="comment">%     Copyright (C) 2016-2017  Luc LAURENT &lt;luc.laurent@lecnam.net&gt;</span>
0007 <span class="comment">%</span>
0008 <span class="comment">%     This program is free software: you can redistribute it and/or modify</span>
0009 <span class="comment">%     it under the terms of the GNU General Public License as published by</span>
0010 <span class="comment">%     the Free Software Foundation, either version 3 of the License, or</span>
0011 <span class="comment">%     (at your option) any later version.</span>
0012 <span class="comment">%</span>
0013 <span class="comment">%     This program is distributed in the hope that it will be useful,</span>
0014 <span class="comment">%     but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
0015 <span class="comment">%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
0016 <span class="comment">%     GNU General Public License for more details.</span>
0017 <span class="comment">%</span>
0018 <span class="comment">%     You should have received a copy of the GNU General Public License</span>
0019 <span class="comment">%     along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
0020 
0021 <a name="_sub0" href="#_subfunctions" class="code">function toolGeneMonomial(polyOrder,nbVar)</a>
0022 
0023 <span class="keyword">if</span> nargin&lt;2
0024     <span class="comment">% order</span>
0025     orderMin=10;
0026     orderMax=10;
0027     <span class="comment">% nb of variables</span>
0028     npMin=10;
0029     npMax=10;
0030 <span class="keyword">else</span>
0031     orderMin=polyOrder;
0032     orderMax=polyOrder;
0033     npMin=nbVar;
0034     npMax=nbVar;
0035 <span class="keyword">end</span>
0036 <span class="comment">%path of the function</span>
0037 nameFun=mfilename;
0038 nameFunFull=mfilename(<span class="string">'fullpath'</span>);
0039 dirFun=strrep(nameFunFull,nameFun,<span class="string">''</span>);
0040 
0041 <span class="comment">%directory of storage</span>
0042 dirMB=fullfile(dirFun,<span class="string">'monomial_basis'</span>);
0043 <span class="keyword">if</span> exist(dirMB,<span class="string">'dir'</span>)~=7
0044     unix([<span class="string">'mkdir '</span> dirMB])
0045 <span class="keyword">end</span>
0046 
0047 <span class="comment">%fichier de stockage</span>
0048 file=<span class="string">'mono'</span>;
0049 ext=<span class="string">'.m'</span>;
0050 
0051 <span class="comment">%stockage</span>
0052 mono1=cell(orderMax,npMax);
0053 monod1=mono1;
0054 monod2=mono1;
0055 cmonod1=mono1;
0056 cmonod2=mono1;
0057 <span class="comment">%matlabpool(8)</span>
0058 listOrder=orderMin:orderMax;
0059 
0060 <span class="keyword">for</span> itD=1:numel(listOrder)
0061     <span class="keyword">for</span> nbv=npMin:npMax
0062         deg=listOrder(itD);
0063         fprintf(<span class="string">'Build Monomials: deg = %i  dim = %i\n'</span>,deg,nbv)
0064         <span class="comment">%valeurs pour chaques variables</span>
0065         val_var=cell(nbv,1);
0066         <span class="keyword">for</span> ii=1:nbv
0067             val_var{ii}=uint8(0:deg);
0068             
0069         <span class="keyword">end</span>
0070         nb_tir=(deg+1)*ones(1,nbv);
0071         
0072         <span class="comment">% generation de la matrice des tirages</span>
0073         <span class="comment">% parcours des variables</span>
0074         
0075         <span class="comment">%         for ii=1:nbv</span>
0076         <span class="comment">%             if ii&gt;1</span>
0077         <span class="comment">%                 nb_ter_pre=prod(nb_tir(1:ii-1));</span>
0078         <span class="comment">%             else</span>
0079         <span class="comment">%                 nb_ter_pre=1;</span>
0080         <span class="comment">%             end</span>
0081         <span class="comment">%             %parcours des valeurs par variables</span>
0082         <span class="comment">%             temp1=[];</span>
0083         <span class="comment">%             for jj=1:length(val_var{ii})</span>
0084         <span class="comment">%                 temp=repmat(val_var{ii}(jj),nb_ter_pre,1);</span>
0085         <span class="comment">%                 temp1=uint8([temp1;temp]);</span>
0086         <span class="comment">%                 clear  temp</span>
0087         <span class="comment">%             end</span>
0088         <span class="comment">%             temp2=repmat(temp1,prod(nb_tir(ii+1:end)),1);</span>
0089         <span class="comment">%             clear temp1 temp</span>
0090         <span class="comment">%             combinaison(:,ii)=temp2;</span>
0091         <span class="comment">%             clear temp2</span>
0092         <span class="comment">%         end</span>
0093         <span class="comment">%         combinaison=combinaison;</span>
0094         
0095         <span class="keyword">for</span> itD=1:numel(listOrder)
0096             <span class="keyword">for</span> nbv=npMin:npMax
0097                 deg=listOrder(itD);
0098                 nbTerms=nchoosek(nbv+deg,deg);
0099                 <span class="comment">%</span>
0100                 combMono=uint8(zeros(nbTerms,nbv));
0101                 <span class="keyword">for</span> itT=1:nbTerms-1
0102                     combMono(itT+1,:)=<a href="../../../GRENAT/src/libs/Monomial/mono_upto_next_grlex.html" class="code" title="function x = mono_upto_next_grlex ( m, n, x )">mono_upto_next_grlex</a>(nbv,deg,combMono(itT,:));
0103                 <span class="keyword">end</span>
0104             <span class="keyword">end</span>
0105         <span class="keyword">end</span>
0106         combinaison=combMono;
0107         
0108         <span class="comment">% g�n�ration combinaison</span>
0109         <span class="comment">%levels=(deg+1)*ones(1,nbv,'uint8');</span>
0110         <span class="comment">%combinaison=sparse(fullfact(levels)-1);</span>
0111         <span class="comment">%suppression ligne td sum term&gt;deg</span>
0112         <span class="comment">%ind=[];</span>
0113         
0114         <span class="comment">%parfor cc=1:size(combinaison,1)</span>
0115         <span class="comment">%    if sum(combinaison(cc,:))&gt;deg</span>
0116         <span class="comment">%        ind=[ind cc];</span>
0117         <span class="comment">%    end</span>
0118         <span class="comment">%end</span>
0119         [ind]=find(sum(combinaison,2)&lt;=deg);
0120         ind=ind';
0121         monomes_pow=combinaison(ind,:);
0122         
0123         clear combinaison
0124         <span class="comment">%puissance monomes</span>
0125         
0126         <span class="comment">%monomes_pow(ind,:)=[];</span>
0127         nbMono=size(monomes_pow,1);
0128         clear ind
0129         <span class="comment">%coef deriv�es premi�re et monomes d�riv�es premi�res</span>
0130         coef_der1=monomes_pow;
0131         monomes_der1=repmat(monomes_pow,1,nbv);
0132         <span class="keyword">for</span> pp=1:nbv
0133             monomes_der1(:,(pp-1)*nbv+pp)=monomes_der1(:,(pp-1)*nbv+pp)-1;
0134         <span class="keyword">end</span>
0135         <span class="comment">%cancel zeros terms due to coefficients equal to zeros</span>
0136         IXc=repmat(1:nbv,nbv,1);
0137         coeftmp=coef_der1(:,IXc(:)');
0138         monomes_der1(coeftmp==0)=0;
0139         <span class="comment">%for cc=1:numel(monomes_der1)</span>
0140         <span class="comment">%    if monomes_der1(cc)&lt;0</span>
0141         <span class="comment">%        monomes_der1(cc)=0;</span>
0142         <span class="comment">%    end</span>
0143         <span class="comment">%end</span>
0144         <span class="comment">%[ind]=find(monomes_der1&lt;0);</span>
0145         <span class="comment">%monomes_der1(ind)=0;</span>
0146         clear ind
0147         <span class="comment">%coef deriv�es secondes et monomes d�riv�es secondes</span>
0148         tt=[];
0149         <span class="keyword">for</span> hh=1:size(coef_der1,2)
0150             tt=[tt repmat(coef_der1(:,hh),1,nbv)];
0151         <span class="keyword">end</span>
0152         <span class="comment">%                 tt</span>
0153         <span class="comment">%         tmp=repmat(tt,1,nbv);</span>
0154         <span class="comment">%         tmp</span>
0155         <span class="comment">%         tmp=reshape(tmp,nbMono,nbv*nbv);</span>
0156         <span class="comment">%         tmp</span>
0157         <span class="comment">%         monomes_der1</span>
0158         coef_der2=monomes_der1.*tt;
0159         monomes_der2=int8(repmat(monomes_der1,1,nbv));
0160         <span class="keyword">for</span> pp=1:nbv
0161             <span class="keyword">for</span> oo=1:nbv
0162                 indd=(oo-1)*nbv+(pp-1)*nbv^2+pp;
0163                 monomes_der2(:,indd)=monomes_der2(:,indd)-1;
0164                 
0165             <span class="keyword">end</span>
0166         <span class="keyword">end</span>
0167         <span class="comment">%coef_der2=reshape(monomes_der2,,nbv)</span>
0168         <span class="keyword">for</span> cc=1:numel(monomes_der2)
0169             <span class="keyword">if</span> monomes_der2(cc)&lt;0
0170                 monomes_der2(cc)=0;
0171             <span class="keyword">end</span>
0172         <span class="keyword">end</span>
0173         <span class="comment">%cancel zeros terms due to coefficients equal to zeros</span>
0174         IXc=repmat(1:nbv^2,nbv,1);
0175         coeftmp=coef_der2(:,IXc(:)');
0176         monomes_der2(coeftmp==0)=0;
0177         <span class="comment">%[ind]=find(monomes_der2&lt;0);</span>
0178         <span class="comment">%monomes_der2(ind)=0;</span>
0179         clear ind
0180         <span class="comment">%sauvegarde r�sultats</span>
0181         mono1{itD,nbv}=monomes_pow;
0182         monod1{itD,nbv}=monomes_der1;
0183         monod2{itD,nbv}=monomes_der2;
0184         cmonod1{itD,nbv}=coef_der1;
0185         cmonod2{itD,nbv}=coef_der2;
0186         clear combinaison comb_mod temp temp1 temp2 ind indd
0187         clear monomes_pow monomes_der1 monomes_der2 coef_der2 coef_der1
0188     <span class="keyword">end</span>
0189 <span class="keyword">end</span>
0190 
0191 fprintf(<span class="string">'Start storing data in files\n'</span>)
0192 <span class="comment">%stockage des monomes</span>
0193 <span class="keyword">for</span> itD=1:numel(listOrder)
0194     <span class="keyword">for</span> jj=npMin:npMax
0195         
0196         fonction=[file <span class="string">'_'</span> num2str(listOrder(itD),<span class="string">'%02i'</span>) <span class="string">'_'</span> num2str(jj,<span class="string">'%03i'</span>)];
0197         fichier=[dirMB <span class="string">'/'</span> fonction ext];
0198         fid=fopen(fichier,<span class="string">'w'</span>);
0199         fprintf(fid,<span class="string">'%s\n\n'</span>,[<span class="string">'function [poly,polyD,polyDD]='</span> fonction <span class="string">'()'</span>]);
0200         fprintf(fid,<span class="string">'derprem=false;dersecond=false;\n'</span>);
0201         fprintf(fid,<span class="string">'if nargout&gt;=2;derprem=true;end\n'</span>);
0202         fprintf(fid,<span class="string">'if nargout==3;dersecond=true;end\n\n'</span>);
0203         <span class="comment">%fprintf(fid,'nb_val=size(X,1);\n nb_var=size(X,2);\n\n');</span>
0204         <span class="comment">%fprintf(fid,'Vones=ones(nb_val,1);\n');</span>
0205         <span class="comment">%fprintf(fid,'Vzeros=zeros(nb_val,1);\n\n');</span>
0206         mat=mono1{itD,jj}';
0207         <span class="comment">%balayage des puissances du monome et construction de la matrice</span>
0208         <span class="comment">%associ�e</span>
0209         Smat=size(mat);
0210         fprintf(fid,<span class="string">'Xpow=[\n'</span>);
0211         fprintf(fid,[repmat(<span class="string">'%i '</span>,1,Smat(2)) <span class="string">'\n'</span>],mat');
0212         fprintf(fid,<span class="string">'];\n'</span>);
0213         fprintf(fid,<span class="string">'poly.Xpow=reshape(Xpow'',[1,%i,%i]);\n'</span>,Smat(2),Smat(1));
0214         fprintf(fid,<span class="string">'Xcoef=[\n'</span>);
0215         fprintf(fid,[repmat(<span class="string">'%i '</span>,1,Smat(2)) <span class="string">'\n'</span>],ones(Smat));
0216         fprintf(fid,<span class="string">'];\n'</span>);
0217         fprintf(fid,<span class="string">'poly.Xcoef=reshape(Xcoef,[1,%i,%i]);\n'</span>,Smat(2),Smat(1));
0218         fprintf(fid,<span class="string">'poly.nbMono=%i;\n\n'</span>,Smat(2));
0219         <span class="comment">%keyboard</span>
0220         <span class="comment">%writing first derivatives</span>
0221         matD=monod1{itD,jj}';
0222         matC=cmonod1{itD,jj}';
0223         fprintf(fid,<span class="string">'if derprem\n'</span>);
0224         fprintf(fid,<span class="string">'DXpow=[\n'</span>);
0225         fprintf(fid,[repmat(<span class="string">'%i '</span>,1,Smat(2)) <span class="string">'\n'</span>],matD');
0226         fprintf(fid,<span class="string">'];\n'</span>);
0227         fprintf(fid,<span class="string">'polyD.Xpow=permute(reshape(DXpow'',%i,1,%i,%i),[2 1 3 4]);\n'</span>,Smat(2),Smat(1),Smat(1));
0228         <span class="comment">%</span>
0229         fprintf(fid,<span class="string">'DXcoef=[\n'</span>);
0230         fprintf(fid,[repmat(<span class="string">'%i '</span>,1,Smat(2)) <span class="string">'\n'</span>],matC');
0231         fprintf(fid,<span class="string">'];\n'</span>);
0232         fprintf(fid,<span class="string">'polyD.Xcoef=reshape(DXcoef'',[1,%i,%i]);\n'</span>,Smat(2),Smat(1));
0233         fprintf(fid,<span class="string">'end\n\n'</span>);
0234         <span class="comment">%keyboard</span>
0235         <span class="comment">%writing second derivatives</span>
0236         matDD=monod2{itD,jj}';
0237         matCC=cmonod2{itD,jj}';
0238         fprintf(fid,<span class="string">'if dersecond\n'</span>);
0239         fprintf(fid,<span class="string">'DDXpow=[\n'</span>);
0240         fprintf(fid,[repmat(<span class="string">'%i '</span>,1,Smat(2)) <span class="string">'\n'</span>],matDD');
0241         fprintf(fid,<span class="string">'];\n'</span>);
0242         fprintf(fid,<span class="string">'polyDD.Xpow=permute(reshape(DDXpow'',%i,1,%i,%i),[2 1 3 4]);\n'</span>,Smat(2),Smat(1),Smat(1)*Smat(1));
0243         <span class="comment">%</span>
0244         fprintf(fid,<span class="string">'DDXcoef=[\n'</span>);
0245         fprintf(fid,[repmat(<span class="string">'%i '</span>,1,Smat(2)) <span class="string">'\n'</span>],matCC');
0246         fprintf(fid,<span class="string">'];\n'</span>);
0247         fprintf(fid,<span class="string">'polyDD.Xcoef=reshape(DDXcoef'',[1,%i,%i]);\n'</span>,Smat(2),Smat(1)^2);
0248         fprintf(fid,<span class="string">'end\n\n'</span>);
0249         fprintf(fid,<span class="string">'end\n\n'</span>);
0250         <span class="comment">%keyboard</span>
0251         <span class="comment">%</span>
0252         fclose(fid);
0253     <span class="keyword">end</span>
0254 <span class="keyword">end</span>
0255 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Wed 02-Oct-2019 17:46:23 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>