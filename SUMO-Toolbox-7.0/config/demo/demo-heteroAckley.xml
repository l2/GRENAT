<?xml version="1.0" encoding="ISO-8859-1" ?>
<!-- Revision Id: $Id: demo-heteroAckley.xml 6377 2009-12-11 11:20:29Z dgorissen $ -->

<!-- Automatically determine the best fitting model type for the 2D Ackley problem -->

<ToolboxConfiguration version="7.0">

	<Plan>
		<LevelPlot>default</LevelPlot>
		<ContextConfig>default</ContextConfig>
		<SUMO>default</SUMO>
		<Simulator>Math/Ackley/Ackley2D.xml</Simulator>

		<Run name="#simulator#_#adaptivemodelbuilder#" repeat="1">
			<AdaptiveModelBuilder>heterogenetic</AdaptiveModelBuilder>
			<InitialDesign>lhdWithCornerPoints</InitialDesign>
			<SampleSelector>default</SampleSelector>
			<SampleEvaluator>matlab</SampleEvaluator>

			<Measure type="ValidationSet" target=".001" errorFcn="rootMeanSquareError">
					<Option key="type" value="file"/>
					<SampleEvaluator type="ibbt.sumo.sampleevaluators.datasets.ScatteredDatasetSampleEvaluator">
						<Option key="id" value="validation"/>
					</SampleEvaluator>
            </Measure>
		</Run>
	</Plan>

	<!-- /////////////////////////////////////////////////////////////////////// -->

	<ContextConfig id="default">
		<OutputDirectory>output</OutputDirectory>
		<PlotOptions>

			<Option key="saveModels" value="true"/>
			<Option key="plotModels" value="true"/>
			<Option key="withContour" value="true"/>
			<Option key="plotContour" value="false" />
			<Option key="outputType" value="png"/>
		</PlotOptions>
		
		<Option key="keepOldModels" value="off"/>
		<Option key="parallelMode" value="off"/>
				
		<Profiling>
			<Profiler name=".*SampleMinimum.*|.*Measure.*|.*BestModel.*|.*ElapsedTime.*|.*MemoryUse.*|.*LevelPlot.*|.*share.*" enabled="true">
				<Output type="toTable"/>
				<Output type="toImage"/>
				<Output type="toFile"/>
				<Output type="toPanel"/>
			</Profiler>		
		</Profiling>
		
	</ContextConfig>
	
	<!-- /////////////////////////////////////////////////////////////////////// -->
	<!-- The logging configuration should be left alone under normal circumstances -->
	<Logging>

		<!-- Root logger -->
		<RootLogger>
		
			<Option key="runsInMainLog" value="true"/>
			<Option key="Level" value="INFO"/>
			 
			<Handlers>
				<ConsoleHandler>
					<Option key="Level" value="INFO"/>
				</ConsoleHandler>

				<FileHandler>
					<Option key="Level" value="ALL"/>
				</FileHandler>
			</Handlers>
		</RootLogger>
		
		<Option key="ibbt.sumo" value="FINEST"/> 
		<Option key="Matlab" value="FINEST"/> 
	</Logging>

	<!-- /////////////////////////////////////////////////////////////////////// -->
	<!-- A Level plot is a kind error histogram of the best model over time -->
	<LevelPlot id="default" type="LevelPlot" combineOutputs="true">
		<!--
		This option enables the levelPlotProfiler (be sure to enable it in the
	        profilers section too). A sample evaluator should provide the reference
        	data set to be used.
        	-->
		<Option key="makeLevelPlots" value="on"/>

		<!-- This tag defines the SampleEvaluator that is used by the levelplot
		     (it needs to get its data from somewhere) -->
		<SampleEvaluator type="ibbt.sumo.sampleevaluators.datasets.GriddedDatasetSampleEvaluator">
			<Option key="id" value="test"/>
		</SampleEvaluator>
	</LevelPlot>	
	<!-- /////////////////////////////////////////////////////////////////////// -->

	<SUMO id="default" type="SUMO">
		<Option key="createMovie" value="yes"/>
		<Option key="minimumTotalSamples" value="0"/>
		<Option key="maximumTotalSamples" value="150"/>
		<Option key="maximumTime" value="Inf"/>
		<Option key="maxModelingIterations" value="Inf"/>
		<Option key="seedRandomState" value="default"/>			
		<Option key="stopOnError" value="true"/>
		<Option key="minimumInitialSamples" value="100%"/>
		<Option key="maximumSamples" value="30"/>
		<Option key="minimumAdaptiveSamples" value="0" />
		<Option key="newSamplesMustSatisfyConstraints" value="yes"/>
		<Option key="adaptiveModelingInitialDesignOnly" value="false"/>
	</SUMO>
	
	<!-- /////////////////////////////////////////////////////////////////////// -->
	
	
	<!-- Evaluate samples using a matlab script (ie. your simulator is a matlab script) -->
	<SampleEvaluator id="matlab" type="ibbt.sumo.sampleevaluators.matlab.MatlabSampleEvaluator">
		<!-- Maximum number of times to resubmit a point (e.g., in case something went wrong) -->
		<Option key="maxResubmissions" value="1"/>
		<!-- If a sample takes longer than "sampleTimeout*average evaluation time of one sample" 
		seconds to evaluate it is removed from the pending list (set to -1 to disable) -->
		<Option key="sampleTimeout" value="-1"/>
	</SampleEvaluator>

	<!-- An adaptive sample selection algorithm (error based), driven by the evaluation of your model on a dense grid -->
	<SampleSelector id="error" type="PipelineSampleSelector" combineOutputs="false">
	
		<CandidateGenerator type="GridCandidateGenerator"/>
		
		<CandidateRanker type="modelDifference">
        	<Option key="criterion_parameter" value="4"/>
        </CandidateRanker>
        
        <MergeCriterion type="ClosenessThreshold">
		
			<!-- Closeness threshold, Double -->
			<Option key="closenessThreshold" value="0.2"/>
			<!-- Set a % of the maximumSamples to randomly chosen -->
			<Option key="randomPercentage" value="20"/>
		
			<Option key="debug" value="off" />
		</MergeCriterion>
	</SampleSelector>
	
	
	<!-- A highly adaptive sampling algorithm, error and density based -->
	<SampleSelector id="lola-voronoi" type="LOLAVoronoiSampleSelector" combineOutputs="false">
		<!-- Integer between 2 and 20 -->
		<Option key="neighbourhoodSize" value="2"/>
	</SampleSelector>

	<!-- LOLA sample selector combined with error based sample selector (default) -->
	<SampleSelector id="default" type="CombinedSampleSelector" combineOutputs="false">
		<SampleSelector weight="0.7">lola-voronoi</SampleSelector>
		<SampleSelector weight="0.3">error</SampleSelector>
	</SampleSelector>
	
	
	<!-- /////////////////////////////////////////////////////////////////////// -->

	<!--A heterogeneous genetic model builder.  Uses a genetic algorithm with speciation (island model)
	      to evolve different model types together.  The models types compete against each other until the
	      best model prevails. So this model builder is a way to automatically select the best model type. -->
	<AdaptiveModelBuilder id="heterogenetic" type="GeneticModelBuilder" combineOutputs="false">
		<Option key="restartStrategy"	value="continue"/>
		<Option key="populationType" value="custom"/>
		<!-- the population size must match the number of model interfaces minus 1 -->
		<Option key="populationSize" value="10,10,10,10,10,10"/>
		<Option key="maxGenerations" value="10"/>
		<Option key="crossoverFraction" value="0.7"/> 
		<Option key="eliteCount" value="1"/>
		<Option key="stallGenLimit" value="4"/>
		<Option key="stallTimeLimit" value="Inf"/>
		<Option key="migrationDirection" value="forward"/>
		<Option key="migrationFraction" value="0.1"/>
		<Option key="migrationInterval" value="4"/>
		<!-- Do we want to prevent any model type going completely extinct -->
		<Option key="extinctionPrevention" value="yes"/>	
	
		<ModelFactory id="hetero" type="HeterogeneousFactory">
			<Option key="creationFcn" value="createInitialPopulation"/>
			<Option key="crossoverFcn" value="crossover"/>
			<Option key="mutationFcn" value="mutation"/>
			
			<ModelFactory id="Ensemble" type="EnsembleFactory">
				<Option key="crossoverFcn" value="crossover"/>
				<Option key="mutationFcn" value="mutation"/>
				<!-- the maximum ensemble size -->
				<Option key="maxSize" value="4"/>
				<!-- Ensemble members should differ this much percent -->
				<Option key="equalityThreshold" value="0.05"/>
			</ModelFactory>

			<ModelFactory id="LSSVM" type="SVMFactory">
				<Option key="creationFcn" value="createInitialPopulation"/>
				<Option key="crossoverFcn" value="crossover"/>
				<Option key="mutationFcn" value="mutation"/>
				
				<Option key="backend" 			value="lssvm"/>
				<Option key="kernel" 			value="rbf"/>
				<Option key="kernelParamBounds" 	value="-2,2"/>
				<Option key="regParamBounds" 		value="-5,5"/>
			</ModelFactory>
			
			<ModelFactory id="nann" type="NANNFactory"> 	 
				<Option key="crossoverFcn" value="crossover"/> 	 
				<Option key="mutationFcn" value="mutation"/> 	 
				<Option key="creationFcn" value="createInitialPopulation"/> 	 
				
				<!--initial hidden layer dimension--> 	 
				<Option key="initialSize" value="10"/> 	 
				<!--how many epochs to train for--> 	 
				<Option key="epochs" value="500"/> 	 
				<!--range of initial random weights--> 	 
				<Option key="initWeightRange" value="-0.8,0.8"/> 	 
				<!--mutation changes x neurons at a time (in a random layer) with x in [lb ub]--> 	 
				<Option key="hiddenUnitDelta" value="-2,3"/> 	 
				<!-- pruning techniques used : 0: none, 1: Mag Threshold, 2: Iterative Mag, 3: OBD, 4: OBS --> 	 
				<Option key="allowedPruneTechniques" value="0,1,2,3,4"/>
				<!-- threshold for magnitude based pruning --> 	 
				<Option key="threshold" value="0.2"/> 	 
				<!-- retrain epochs while pruning--> 	 
				<Option key="retrain" value="50"/> 	 
			</ModelFactory> 	 
			
			<ModelFactory type="RationalFactory">
				<Option key="crossoverFcn" value="crossover"/>
				<Option key="mutationFcn" value="mutation"/>
				<Option key="creationFcn" value="createInitialPopulation"/>
				<Option key="weightBounds" value="1,40"/>
				<Option key="percentBounds" value="1,100"/>
				<Option key="percentRational" value="70"/>
				<Option key="frequencyVariable" value="off"/>
				<Option key="basis" value="power"/>
			</ModelFactory>

			<ModelFactory type="BFFactory">
				<Option key="type" value="RBF"/>

				<Option key="crossoverFcn" value="crossover"/>
				<Option key="mutationFcn" value="mutation"/>
				<Option key="creationFcn" value="createInitialPopulation"/>
				
				<BasisFunction name="gaussian"     min=".1"    max="5"    scale="ln"/>
				<BasisFunction name="multiquadric" min=".1"    max="5"    scale="ln"/>
				<BasisFunction name="exponential"  min=".1,.5" max="5,2"  scale="ln,lin"/>
				
				<Option key="regression" value="-1,0,1,2"/>
				<Option key="backend" value="Direct"/>
			</ModelFactory>			
			
			<ModelFactory id="spline" type="SplineFactory">
				<Option key="creationFcn" value="createInitialPopulation"/>
				<Option key="crossoverFcn" value="crossover"/>
				<Option key="mutationFcn" value="mutation"/> -->
				<Option key="smoothingBounds" value="0,1"/>	
			</ModelFactory>

			<ModelFactory id="kriging" type="KrigingFactory">
				<Option key="creationFcn" value="createInitialPopulation"/>
				<Option key="crossoverFcn" value="crossover"/>
				<Option key="mutationFcn" value="mutation"/> 
				<Option key="regressionFunction" value="regpoly1"/>
				<Option key="regressionMetric" value="" />
				<Option key="multipleBasisFunctionsAllowed" value="false" />
				<BasisFunction type="BasisFunction" name="corrgauss">
					<Parameter name="theta" min="-2" max="2" scale="log" duplicate="true" />
				</BasisFunction>
			</ModelFactory>
			
		</ModelFactory>
	</AdaptiveModelBuilder>	
	
<!--+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->
	
	<!-- Specifies a combined Latin HyperCube and FactorialDesign -->
	<InitialDesign id="lhdWithCornerPoints" type="CombinedDesign">
		<!-- Select samples in a Latin Hypercube Design -->
		<InitialDesign type="LatinHypercubeDesign">
			<!-- how many points to generate -->
			<Option key="points" value="16"/>
			<!--<Option key="weight" value="0.5"/>-->
			<!--<Option key="coolingFactor" value="0.9"/>-->
			<!--<Option key="p" value="5.0"/>-->
		</InitialDesign>

		<InitialDesign type="FactorialDesign">
			<!-- how many points to generate for each dimension as a vector -->
			<!-- a scalar value (l) is the same as [l l ... l] (length of input dimension) -->
			<Option key="levels" value="2" />
		</InitialDesign>
	</InitialDesign>

<!--+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-->

</ToolboxConfiguration>

